RegAlloc 6b

Charles Proctor, crp43
04/06/2017

<i> I have implemented a compiling, and *slightly* tested version of the RegAlloc module. That includes:

    - makegraph.sml : builds a control flow graph
    - liveness.sml : builds the interference graph
    - liveset.sml : used by liveness.sml to maintain a set of live temporaries
    - regalloc.sml : performs the graph-coloring register allocation (only simplify + select)

I have tested register allocation on a simple case, namely the example on Appel pp212. For those that would like to reproduce, I have submitted the following files:

    - codegen.sml : The codegen() function outputs a list of instructions modeled after Appel pp212. It also prints human-readable temporary names.
    - main.sml : The emitproc function glues everything together. To help in the debugging / testing, I print out the full register allocation within this function call. I also dump the interference graph to igraph.gv in DOT format.

I used one of the ItreeGen modules to provide a dummy sample to CodeGen...

<ii> To use my RegAlloc module, copy the four files listed above into RegAlloc/ and update the sources.cm as described in <v>. In main.sml, you'll have to add at least the following lines of code...

```
(* convert assembly instructions to flowgraph and list of nodes *)
val (flowgraph, nodes) = MakeGraph.instrs2graph(instrs)

(* convert flowgraph to interference graph and liveout mapping *)
val (igraph, liveout_mapping) = Liveness.interferenceGraph(flowgraph)

(* graph coloring to allocate registers for all temporaries *)
val allocation = RegAlloc.color{
    interference=igraph,
    initial=initial,
    registers=registers
}
```

where
- instrs is the list of assembly instructions
- initial is a mapping of pre-allocated registers
- registers is the list of registers available

and allocation is a mapping from temporaries to registers.

<iii> As before, I assume that there are enough registers for all temporaries... ie, that no spilling is necessary. No other major assumptions come to mind.

<iv> I would like the CodeGen group to work on

1. defining the list registers that are available
1. generating more complex instruction sequences, so that I can better test my register allocation scheme
2. the procEntryExit function, so everything can be hooked together.

<v> I added liveset.sml to maintain a LiveSet data structure. The updated sources.cm is in this directory, created by simply adding

    RegAlloc/liveset.sml
